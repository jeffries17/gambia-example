#!/usr/bin/env python3
"""
Tourism Board Report Generator

Creates comprehensive, professional reports for tourism boards based on
TripAdvisor sentiment analysis and insights.
"""

import os
import json
from datetime import datetime
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)

class TourismReportGenerator:
    """
    Generates professional reports for tourism boards from sentiment analysis data.
    """
    
    def __init__(self, output_dir='outputs/reports'):
        """Initialize the report generator."""
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
    
    def generate_executive_report(self, insights: Dict) -> str:
        """Generate an executive summary report."""
        metadata = insights.get('analysis_metadata', {})
        destination = metadata.get('destination', 'Unknown Destination')
        
        report = f"""
# TOURISM SENTIMENT ANALYSIS REPORT
## Executive Summary for {destination}

**Analysis Date:** {datetime.now().strftime('%B %d, %Y')}
**Data Source:** TripAdvisor Reviews
**Total Reviews Analyzed:** {metadata.get('total_reviews', 0)}
**Business Category:** {metadata.get('category', 'Unknown').title()}

---

## KEY FINDINGS

### Overall Sentiment Score: {insights.get('overall_sentiment', {}).get('overall_score', 0):.2f}
- **Rating:** {self._sentiment_to_rating(insights.get('overall_sentiment', {}).get('overall_score', 0))}
- **Positive Reviews:** {insights.get('overall_sentiment', {}).get('sentiment_distribution', {}).get('positive_percentage', 0):.1f}%
- **Negative Reviews:** {insights.get('overall_sentiment', {}).get('sentiment_distribution', {}).get('negative_percentage', 0):.1f}%

### Confidence Level: {insights.get('overall_sentiment', {}).get('confidence_level', 'Unknown')}

---

## ASPECT-BASED ANALYSIS

{self._format_aspect_analysis(insights.get('aspect_sentiment', {}))}

---

## KEY THEMES & INSIGHTS

{self._format_themes_analysis(insights.get('recurring_themes', {}))}

---

## LANGUAGE DIVERSITY

{self._format_language_analysis(insights.get('language_analysis', {}))}

---

## SERVICE RESPONSIVENESS

{self._format_responsiveness_analysis(insights.get('responsiveness_analysis', {}))}

---

## STRATEGIC RECOMMENDATIONS

{self._format_recommendations(insights.get('executive_summary', {}))}

---

## METHODOLOGY
This analysis was conducted using advanced sentiment analysis techniques on publicly available TripAdvisor reviews. 
All reviewer information has been anonymized to protect privacy while maintaining analytical integrity.

**Generated by:** TripAdvisor Sentiment Analysis System
**Report Date:** {datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        # Save report
        filename = f"executive_report_{destination.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.md"
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(report)
        
        logger.info(f"Executive report saved to: {filepath}")
        return filepath
    
    def generate_detailed_analysis(self, insights: Dict) -> str:
        """Generate detailed analysis report with all metrics."""
        metadata = insights.get('analysis_metadata', {})
        destination = metadata.get('destination', 'Unknown Destination')
        
        report = f"""
# DETAILED TOURISM ANALYSIS REPORT
## {destination} - Comprehensive Sentiment Analysis

**Prepared for:** Tourism Board / Destination Marketing Organization
**Analysis Period:** {datetime.now().strftime('%B %Y')}
**Source Data:** {metadata.get('source_url', 'TripAdvisor')}

---

## 1. OVERALL SENTIMENT METRICS

### Primary Indicators
- **Overall Sentiment Score:** {insights.get('overall_sentiment', {}).get('overall_score', 0):.3f} (Range: -1.0 to +1.0)
- **Average Rating:** {insights.get('overall_sentiment', {}).get('average_rating', 0):.1f}/5.0 stars
- **Total Reviews Analyzed:** {metadata.get('total_reviews', 0)}

### Sentiment Distribution
{self._format_sentiment_distribution(insights.get('overall_sentiment', {}))}

---

## 2. ASPECT-BASED SENTIMENT ANALYSIS

{self._format_detailed_aspects(insights.get('aspect_sentiment', {}))}

---

## 3. KEYWORD & PHRASE ANALYSIS

{self._format_keywords_analysis(insights.get('keywords_phrases', {}))}

---

## 4. RECURRING THEMES ANALYSIS

{self._format_detailed_themes(insights.get('recurring_themes', {}))}

---

## 5. INTERNATIONAL MARKET ANALYSIS

{self._format_detailed_language(insights.get('language_analysis', {}))}

---

## 6. SERVICE QUALITY INDICATORS

{self._format_detailed_responsiveness(insights.get('responsiveness_analysis', {}))}

---

## 7. COMPETITIVE POSITIONING RECOMMENDATIONS

{self._format_competitive_recommendations(insights)}

---

## APPENDIX: DATA QUALITY & METHODOLOGY

### Sample Characteristics
- **Sample Size:** {metadata.get('total_reviews', 0)} reviews
- **Confidence Level:** {insights.get('overall_sentiment', {}).get('confidence_level', 'Unknown')}
- **Data Source:** {metadata.get('source_url', 'TripAdvisor')}
- **Analysis Framework:** Multi-dimensional sentiment analysis with aspect-based classification

### Limitations
- Analysis based on publicly available reviews only
- Sentiment analysis accuracy dependent on review language and context
- Sample may not represent all visitor segments

**Report Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        # Save detailed report
        filename = f"detailed_analysis_{destination.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.md"
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(report)
        
        logger.info(f"Detailed analysis saved to: {filepath}")
        return filepath
    
    def generate_comparison_report(self, comparison_data: Dict) -> str:
        """Generate a destination comparison report."""
        destinations = comparison_data.get('comparison_metadata', {}).get('destinations', [])
        destination_names = ' vs '.join(destinations)
        
        report = f"""
# DESTINATION COMPARISON REPORT
## {destination_names}

**Comparison Date:** {datetime.now().strftime('%B %d, %Y')}
**Total Reviews Analyzed:** {comparison_data.get('comparison_metadata', {}).get('total_reviews', 0)}

---

## COMPETITIVE OVERVIEW

{self._format_comparison_overview(comparison_data.get('overall_comparison', {}))}

---

## SENTIMENT COMPARISON

{self._format_sentiment_comparison(comparison_data.get('sentiment_comparison', {}))}

---

## ASPECT PERFORMANCE COMPARISON

{self._format_aspect_comparison(comparison_data.get('aspect_comparison', {}))}

---

## STRATEGIC INSIGHTS

{self._format_comparison_insights(comparison_data)}

---

## RECOMMENDATIONS FOR COMPETITIVE ADVANTAGE

{self._format_competitive_advantage_recommendations(comparison_data)}

**Report Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        # Save comparison report
        filename = f"comparison_report_{datetime.now().strftime('%Y%m%d_%H%M')}.md"
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(report)
        
        logger.info(f"Comparison report saved to: {filepath}")
        return filepath
    
    # Helper formatting methods
    def _sentiment_to_rating(self, score: float) -> str:
        """Convert sentiment score to descriptive rating."""
        if score > 0.6:
            return "Excellent"
        elif score > 0.3:
            return "Good"
        elif score > 0:
            return "Fair"
        elif score > -0.3:
            return "Poor"
        else:
            return "Very Poor"
    
    def _format_aspect_analysis(self, aspects: Dict) -> str:
        """Format aspect analysis for executive summary."""
        if not aspects:
            return "No aspect-specific data available."
        
        formatted = []
        for aspect, data in aspects.items():
            sentiment = data.get('average_sentiment', 0)
            percentage = data.get('mention_percentage', 0)
            rating = self._sentiment_to_rating(sentiment)
            
            formatted.append(f"**{aspect.title()}:** {rating} ({sentiment:.2f}) - Mentioned in {percentage:.1f}% of reviews")
        
        return '\n'.join(formatted)
    
    def _format_themes_analysis(self, themes: Dict) -> str:
        """Format themes analysis."""
        if not themes:
            return "No significant themes identified."
        
        formatted = []
        for theme, data in themes.items():
            percentage = data.get('percentage', 0)
            sentiment = data.get('average_sentiment', 0)
            
            if percentage > 10:  # Only show themes mentioned in >10% of reviews
                status = "✓ Strength" if sentiment > 0.2 else "⚠ Concern" if sentiment < -0.1 else "→ Neutral"
                formatted.append(f"{status} **{data.get('description', theme)}** - {percentage:.1f}% of reviews")
        
        return '\n'.join(formatted) if formatted else "No major themes identified."
    
    def _format_language_analysis(self, lang_data: Dict) -> str:
        """Format language diversity analysis."""
        if not lang_data:
            return "Language analysis not available."
        
        diversity_score = lang_data.get('diversity_score', 0)
        international_appeal = lang_data.get('international_appeal', 0)
        
        return f"""
**Market Diversity Score:** {diversity_score}/10
**International Visitors:** {international_appeal:.1f}% of reviews in non-English languages
**Primary Language:** {lang_data.get('primary_language', 'Unknown').title()}
"""
    
    def _format_responsiveness_analysis(self, resp_data: Dict) -> str:
        """Format responsiveness analysis."""
        if not resp_data:
            return "Responsiveness analysis not available."
        
        score = resp_data.get('overall_responsiveness_score', 0)
        
        rating = "Excellent" if score > 20 else "Good" if score > 10 else "Needs Improvement"
        
        return f"""
**Responsiveness Rating:** {rating} ({score:.1f}% of reviews mention responsive service)
**Key Areas:** {', '.join(resp_data.get('responsiveness_areas', {}).keys())}
"""
    
    def _format_recommendations(self, summary: Dict) -> str:
        """Format strategic recommendations."""
        if not summary:
            return "No specific recommendations available."
        
        sections = []
        
        strengths = summary.get('strengths', [])
        if strengths:
            sections.append("### Leverage These Strengths:")
            sections.extend([f"- {strength}" for strength in strengths[:3]])
        
        improvements = summary.get('areas_for_improvement', [])
        if improvements:
            sections.append("\n### Priority Improvements:")
            sections.extend([f"- {improvement}" for improvement in improvements[:3]])
        
        strategic = summary.get('strategic_recommendations', [])
        if strategic:
            sections.append("\n### Strategic Initiatives:")
            sections.extend([f"- {rec}" for rec in strategic[:3]])
        
        return '\n'.join(sections) if sections else "Detailed analysis required for specific recommendations."
    
    def _format_sentiment_distribution(self, overall: Dict) -> str:
        """Format detailed sentiment distribution."""
        dist = overall.get('sentiment_distribution', {})
        
        return f"""
| Sentiment | Percentage | Count |
|-----------|------------|-------|
| Positive  | {dist.get('positive_percentage', 0):.1f}%     | {int(dist.get('positive_percentage', 0) * overall.get('total_reviews', 0) / 100)} |
| Neutral   | {dist.get('neutral_percentage', 0):.1f}%     | {int(dist.get('neutral_percentage', 0) * overall.get('total_reviews', 0) / 100)} |
| Negative  | {dist.get('negative_percentage', 0):.1f}%     | {int(dist.get('negative_percentage', 0) * overall.get('total_reviews', 0) / 100)} |
"""
    
    def _format_detailed_aspects(self, aspects: Dict) -> str:
        """Format detailed aspect analysis."""
        if not aspects:
            return "No aspect-specific data available."
        
        formatted = []
        for aspect, data in aspects.items():
            formatted.append(f"### {aspect.title()}")
            formatted.append(f"- **Sentiment Score:** {data.get('average_sentiment', 0):.3f}")
            formatted.append(f"- **Mention Rate:** {data.get('mention_percentage', 0):.1f}% of reviews")
            formatted.append(f"- **Review Count:** {data.get('mention_count', 0)}")
            
            # Sub-aspects
            sub_aspects = data.get('sub_aspects', {})
            if sub_aspects:
                formatted.append("- **Key Areas:**")
                for sub, sub_data in sub_aspects.items():
                    formatted.append(f"  - {sub.replace('_', ' ').title()}: {sub_data.get('average_sentiment', 0):.2f}")
            
            formatted.append("")
        
        return '\n'.join(formatted)
    
    def _format_keywords_analysis(self, keywords: Dict) -> str:
        """Format keywords and phrases analysis."""
        if not keywords:
            return "Keyword analysis not available."
        
        formatted = []
        
        # Top positive keywords
        positive = keywords.get('positive_keywords', [])[:5]
        if positive:
            formatted.append("### Most Positive Keywords")
            for kw in positive:
                formatted.append(f"- **{kw['word']}** (mentioned {kw['frequency']} times, sentiment: {kw.get('sentiment_score', 0):.2f})")
        
        # Top negative keywords
        negative = keywords.get('negative_keywords', [])[:5]
        if negative:
            formatted.append("\n### Areas of Concern")
            for kw in negative:
                formatted.append(f"- **{kw['word']}** (mentioned {kw['frequency']} times, sentiment: {kw.get('sentiment_score', 0):.2f})")
        
        return '\n'.join(formatted) if formatted else "Keyword analysis incomplete."
    
    def _format_detailed_themes(self, themes: Dict) -> str:
        """Format detailed themes analysis."""
        if not themes:
            return "No significant themes identified."
        
        formatted = []
        for theme, data in themes.items():
            formatted.append(f"### {data.get('description', theme).title()}")
            formatted.append(f"- **Frequency:** {data.get('percentage', 0):.1f}% of reviews")
            formatted.append(f"- **Sentiment:** {data.get('average_sentiment', 0):.3f}")
            formatted.append(f"- **Impact:** {self._sentiment_to_rating(data.get('average_sentiment', 0))}")
            
            # Examples
            examples = data.get('key_examples', [])[:2]
            if examples:
                formatted.append("- **Examples:**")
                for example in examples:
                    formatted.append(f"  - \"{example[:100]}...\"")
            
            formatted.append("")
        
        return '\n'.join(formatted)
    
    def _format_detailed_language(self, lang_data: Dict) -> str:
        """Format detailed language analysis."""
        if not lang_data:
            return "Language analysis not available."
        
        formatted = []
        
        # Language distribution
        distribution = lang_data.get('language_distribution', {})
        if distribution:
            formatted.append("### Language Distribution")
            for lang, data in sorted(distribution.items(), key=lambda x: x[1]['percentage'], reverse=True)[:5]:
                formatted.append(f"- **{lang.title()}:** {data['percentage']:.1f}% ({data['review_count']} reviews)")
        
        # Insights
        insights = lang_data.get('insights', [])
        if insights:
            formatted.append("\n### Market Insights")
            for insight in insights:
                formatted.append(f"- {insight}")
        
        return '\n'.join(formatted) if formatted else "Language analysis incomplete."
    
    def _format_detailed_responsiveness(self, resp_data: Dict) -> str:
        """Format detailed responsiveness analysis."""
        if not resp_data:
            return "Responsiveness analysis not available."
        
        formatted = []
        
        areas = resp_data.get('responsiveness_areas', {})
        for area, data in areas.items():
            formatted.append(f"### {area.replace('_', ' ').title()}")
            formatted.append(f"- **Frequency:** {data.get('percentage', 0):.1f}% of reviews")
            formatted.append(f"- **Sentiment:** {data.get('average_sentiment', 0):.3f}")
            formatted.append("")
        
        recommendations = resp_data.get('recommendations', [])
        if recommendations:
            formatted.append("### Recommendations")
            for rec in recommendations:
                formatted.append(f"- {rec}")
        
        return '\n'.join(formatted) if formatted else "Responsiveness analysis incomplete."
    
    def _format_competitive_recommendations(self, insights: Dict) -> str:
        """Format competitive positioning recommendations."""
        recommendations = []
        
        # Based on sentiment score
        overall_sentiment = insights.get('overall_sentiment', {}).get('overall_score', 0)
        if overall_sentiment > 0.4:
            recommendations.append("**Leverage positive reputation** in marketing materials and testimonials")
        elif overall_sentiment < 0:
            recommendations.append("**Address negative sentiment** through service improvements before major marketing push")
        
        # Based on aspects
        aspects = insights.get('aspect_sentiment', {})
        strong_aspects = [aspect for aspect, data in aspects.items() 
                         if data.get('average_sentiment', 0) > 0.4]
        if strong_aspects:
            recommendations.append(f"**Highlight strengths** in {', '.join(strong_aspects)} in competitive positioning")
        
        # Based on international appeal
        lang_data = insights.get('language_analysis', {})
        international_appeal = lang_data.get('international_appeal', 0)
        if international_appeal > 30:
            recommendations.append("**Market international diversity** as a competitive advantage")
        elif international_appeal < 10:
            recommendations.append("**Develop international marketing strategy** to compete with global destinations")
        
        return '\n'.join([f"- {rec}" for rec in recommendations]) if recommendations else "Competitive analysis requires comparison data."
    
    def _format_comparison_overview(self, comparison: Dict) -> str:
        """Format comparison overview table."""
        if not comparison:
            return "Comparison data not available."
        
        headers = ["Destination", "Avg Rating", "Avg Sentiment", "Reviews", "Category"]
        rows = []
        
        for dest, data in comparison.items():
            rows.append([
                dest,
                f"{data.get('avg_rating', 0):.1f}/5.0",
                f"{data.get('avg_sentiment', 0):.2f}",
                str(data.get('review_count', 0)),
                data.get('business_category', 'Unknown')
            ])
        
        # Simple table formatting
        table = "| " + " | ".join(headers) + " |\n"
        table += "|" + "|".join(["---"] * len(headers)) + "|\n"
        for row in rows:
            table += "| " + " | ".join(row) + " |\n"
        
        return table
    
    def _format_sentiment_comparison(self, sentiment_comp: Dict) -> str:
        """Format sentiment comparison analysis."""
        if not sentiment_comp:
            return "Sentiment comparison not available."
        
        formatted = []
        for dest, data in sentiment_comp.items():
            formatted.append(f"### {dest}")
            formatted.append(f"- **Average Sentiment:** {data.get('avg_sentiment', 0):.3f}")
            formatted.append(f"- **Positive Reviews:** {data.get('positive_count', 0)}")
            formatted.append(f"- **Negative Reviews:** {data.get('negative_count', 0)}")
            formatted.append("")
        
        return '\n'.join(formatted)
    
    def _format_aspect_comparison(self, aspect_comp: Dict) -> str:
        """Format aspect comparison analysis."""
        if not aspect_comp:
            return "Aspect comparison not available."
        
        formatted = []
        
        # Create a comparison table for each aspect found
        all_aspects = set()
        for dest_data in aspect_comp.values():
            for category_data in dest_data.values():
                if isinstance(category_data, dict):
                    all_aspects.update(category_data.keys())
        
        for aspect in list(all_aspects)[:5]:  # Top 5 aspects
            formatted.append(f"### {aspect.replace('_', ' ').title()}")
            for dest, dest_data in aspect_comp.items():
                aspect_score = "N/A"
                for category_data in dest_data.values():
                    if isinstance(category_data, dict) and aspect in category_data:
                        aspect_score = f"{category_data[aspect].get('avg_sentiment', 0):.2f}"
                        break
                formatted.append(f"- **{dest}:** {aspect_score}")
            formatted.append("")
        
        return '\n'.join(formatted) if formatted else "Detailed aspect comparison not available."
    
    def _format_comparison_insights(self, comparison_data: Dict) -> str:
        """Format strategic insights from comparison."""
        insights = []
        
        overall = comparison_data.get('overall_comparison', {})
        if overall:
            # Find best and worst performers
            by_sentiment = sorted(overall.items(), key=lambda x: x[1].get('avg_sentiment', 0), reverse=True)
            if len(by_sentiment) >= 2:
                best = by_sentiment[0]
                worst = by_sentiment[-1]
                
                insights.append(f"**Sentiment Leader:** {best[0]} ({best[1].get('avg_sentiment', 0):.2f})")
                insights.append(f"**Improvement Opportunity:** {worst[0]} ({worst[1].get('avg_sentiment', 0):.2f})")
        
        return '\n'.join([f"- {insight}" for insight in insights]) if insights else "Comparative insights require additional analysis."
    
    def _format_competitive_advantage_recommendations(self, comparison_data: Dict) -> str:
        """Format competitive advantage recommendations."""
        recommendations = [
            "Focus on differentiation through strongest performing aspects",
            "Address weaknesses identified in comparative analysis",
            "Monitor competitor sentiment trends for market positioning",
            "Leverage unique cultural or geographic advantages",
            "Develop targeted marketing based on sentiment strengths"
        ]
        
        return '\n'.join([f"- {rec}" for rec in recommendations])

# Convenience function
def generate_tourism_report(insights_data: Dict, report_type: str = 'executive', output_dir: str = 'outputs/reports') -> str:
    """
    Generate a tourism board report from insights data.
    
    Args:
        insights_data (Dict): Tourism insights analysis data
        report_type (str): Type of report ('executive', 'detailed', 'comparison')
        output_dir (str): Output directory
        
    Returns:
        str: Path to generated report
    """
    generator = TourismReportGenerator(output_dir=output_dir)
    
    if report_type == 'executive':
        return generator.generate_executive_report(insights_data)
    elif report_type == 'detailed':
        return generator.generate_detailed_analysis(insights_data)
    elif report_type == 'comparison':
        return generator.generate_comparison_report(insights_data)
    else:
        raise ValueError(f"Unknown report type: {report_type}") 